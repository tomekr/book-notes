### The Challenge of Complexity

> Many things can put a project off course: bureaucracy, unclear objectives, and lack of resources, to name a few. But it is the approach to design that largely determines how complex software can become. When complexity gets out of hand, developers can no longer understand the software well enough to change or extend it easily and safely. On the other hand, a good design can create opportunities to exploit those complex features.

The premise of this book is twofole:

1. For most software projects, the primary focus should be on the domain and domain logic.
2. Complex domain designs should be based on a model

> Domain-driven design is both a way of thinking and a set of priorities, aimed at accelerating software projects that have to deal with complicated domains.


# Part 1: Putting the Domain Model to Work

Maps are an example of a model, and every model represents some aspect of reality or an idea that is of interest. A model is a simplification. It is an interpretation of reality that abstracts the aspects relevant to solving the problem at hand and ignores extraneous detail.

Every software program relates to some activity or interest of its user. That subject area to
which the user applies the program is the domain of the software. Some domains involve the
physical world: The domain of an airline-booking program involves real people getting on real
aircraft. Some domains are intangible: The domain of an accounting program is money and
finance. Software domains usually have little to do with computers, though there are
exceptions: The domain of a source-code control system is software development itself.

### The utility of a Model in Domain-Driven Design

In domain-driven design, three basic uses determine the choice of a model.

1. The model and the heart of the design shape each other.
2. The model is the backbone of a language used by all team members.
3. The model is distilled knowledge.

_end_

## Chapter 1: Crunching Knowledge


